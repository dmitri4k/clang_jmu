<!DOCTYPE html>

<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    
    <link rel="stylesheet" href="_static/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />
    <link rel="stylesheet" href="_static/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../JSAV/css/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/jquery-1.11.4-smoothness-ui.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    <link rel="stylesheet" href="_static/css/csf.css" type="text/css" />

    <style>
      .underline { text-decoration: underline; }
    </style>

  </head><body>
       
    <div class="container">


<h1>10.5. Functions and Scope<a class="headerlink" href="#functions-and-scope" title="Permalink to this headline">¶</a></h1>
<p>As with every modern programming language, C uses functions to create modularity as a step toward
robust software. Encapsulating portions of a program’s code this way allows the programmer to
isolate the functions for the purposes of testing and debugging. One key aspect of writing functions
is to get the <em>scope</em> of variables correct. <a class="reference external" href="#cla-22">Code Listing A.22</a> illustrates the
three main scopes for variables in C programs: <em>global</em>, <em>local</em>, and <em>static</em>.
The split of global and local is fairly straightforward: if the variable declaration occurs inside
the body of a function (see line 13), it is local to that function and unavailable to others; if the
declaration is outside any function definition (see line 7), the variable is global and accessible
by all functions for reading or modification.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-22"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.22:</span>
<span class="cm">   Declaring local and global functions in a helper function</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">global_static</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">helper</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">local_static</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;global = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">global</span><span class="o">++</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;global_static = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">global_static</span><span class="o">++</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;local = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">local</span><span class="o">++</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;local again = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">local</span><span class="o">++</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;local_static = %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">local_static</span><span class="o">++</span><span class="p">);</span>

    <span class="p">{</span>
      <span class="k">static</span> <span class="kt">int</span> <span class="n">hidden</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
      <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;hidden = %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hidden</span><span class="o">++</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="cm">/* hidden cannot be accessed here */</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In addition to their differences in visibility, local and global variables differ in another key
way: initialization. Global variables are always initialized, whether the code does so explicitly or
not. Consider changing line 7 from <a class="reference external" href="#cla-22">Code Listing A.22</a> as shown here:</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-2 mb-3 notranslate"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="kt">int</span> <span class="n">global</span><span class="p">;</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">global</span></code> is still declared as an <code class="docutils literal notranslate"><span class="pre">int</span></code> variable. It is also initialized to the
value 0. One subtle difference is that the variable now exists in a different memory section than
before. Recall that we can collectively refer to the <em>data segment</em> as the portion of memory
storing global variables. This segment is subdivided into smaller sections, including <code class="docutils literal notranslate"><span class="pre">.data</span></code>
(initialized global variables), <code class="docutils literal notranslate"><span class="pre">.bss</span></code> (<em>block started by symbol</em> for uninitialized global
variables), and <code class="docutils literal notranslate"><span class="pre">.rodata</span></code> (initialized read-only data, such as string constants). In the original
form of <a class="reference external" href="#cla-22">Code Listing A.22</a>, <code class="docutils literal notranslate"><span class="pre">global</span></code> was allocated space in <code class="docutils literal notranslate"><span class="pre">.data</span></code>, and the
executable file would contain its initial value (1). In this modified version, <code class="docutils literal notranslate"><span class="pre">global</span></code> would be
allocated to <code class="docutils literal notranslate"><span class="pre">.bss</span></code>. In the executable file, the <code class="docutils literal notranslate"><span class="pre">.bss</span></code> stores nothing, because it doesn’t need
to; everything allocated to <code class="docutils literal notranslate"><span class="pre">.bss</span></code> has the same initial value of 0. As such, the executable only
needs to contain information about what variables map to <code class="docutils literal notranslate"><span class="pre">.bss</span></code> to know the total size that needs
to be allocated in memory when the process starts. All global variables are mapped into one of these
three sections, ensuring that they all start with some initial value.</p>
<div class="figure mb-2 align-right" id="id14" style="width: 45%">
<span id="rsplocation"></span><a class="reference internal image-reference" href="_images/CSF-Images.A.4.png"><img class="p-3 mb-2 align-center border border-dark rounded-lg" alt="Location of %rsp before and after allocating the stack frame for helper()" src="_images/CSF-Images.A.4.png" style="width: 90%;" /></a>
<p class="caption align-center px-3"><span class="caption-text"> Figure 10.5.1: Location of %rsp before and after allocating the stack frame for helper()</span></p>
</div>
<p>Local variables are different. <strong>Local variables are never initialized unless done so explicitly</strong>.
Unlike global variables, in which there is a single instance that can be stored persistently in the
executable file, local variables are only created at run-time when a function is called. This
allocation happens in a single step: adjusting the stack pointer register (<code class="docutils literal notranslate"><span class="pre">%rsp</span></code> in x86).
<a href="Functions.html#rsplocation">Figure  10.5.1</a> illustrates the portion of the stack before <code class="docutils literal notranslate"><span class="pre">main()</span></code> calls
<code class="docutils literal notranslate"><span class="pre">helper()</span></code> and after doing so.</p>
<p>All global variables have their initial values loaded automatically when the program is first loaded
into memory. Local variables are automatically allocated space in the stack frame when the function
defining their scope is called. However, initializing the variable requires extra instructions, and
these are only performed if the program specifically requests it. That is, if you do not explicitly
initialize your local variables (as line 13 of <a class="reference external" href="#cla-22">Code Listing A.22</a> does), then the
initial value of the local variable happens to be whatever was already in that memory location. Note
that, in general, other functions are likely to have been called before the function you are
currently writing; i.e., <code class="docutils literal notranslate"><span class="pre">main()</span></code> (or related start-up functions) likely called other functions
before <code class="docutils literal notranslate"><span class="pre">helper()</span></code> gets called the first time. Consequently, the initial value of <code class="docutils literal notranslate"><span class="pre">local</span></code> would
be whatever data was left over from those previous function calls.</p>
<div class="topic border border-dark rounded-lg alert-danger px-2 mb-3">
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/CSF-Images-BugWarning.png"><img alt="Decorative bug warning" src="_images/CSF-Images-BugWarning.png" style="width: 90%;" /></a>
</div>
<p class="topic-title first pt-2 mb-1">Bug Warning</p><hr class="mt-1" />
<p>At the risk of overkill on this particular point, it is critical to develop the habit of always
initializing local variables. When this is not done, the program can behave truly randomly. It may
work fine nine times in a row before having a segmentation fault on the tenth run; when the program
is then re-run to debug the segmentation fault, it goes back to working perfectly. It is incredibly
common that such random behavior can be traced back to an uninitialized local variable.</p>
<p>This failure to initialize local variables often arises when working with non-primitive data types,
such as arrays or structs. In this case, the simplest approach is to use <code class="docutils literal notranslate"><span class="pre">memset()</span></code>. The first
parameter is a pointer to a buffer to initialize, the second parameter is what value to write into
each byte and the third parameter is the length of the buffer.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-2 mb-3 notranslate"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">memset</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">data</span><span class="p">));</span> <span class="c1">// initialize all elements to 0</span>

<span class="k">struct</span> <span class="n">stat</span> <span class="n">info</span><span class="p">;</span>
<span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">info</span><span class="p">));</span> <span class="c1">// initialize all fields to 0</span>
</pre></div>
</div>
</div>
<div class="topic border border-dark rounded-lg bg-light px-2 mb-3">
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/CSF-Images-Library.png"><img alt="Decorative C library image" src="_images/CSF-Images-Library.png" style="width: 100%;" /></a>
</div>
<p class="topic-title first pt-2 mb-1">C library functions – &lt;ctype.h&gt;</p><hr class="mt-1" />
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">memset(void</span> <span class="pre">*b,</span> <span class="pre">int</span> <span class="pre">c,</span> <span class="pre">size_t</span> <span class="pre">len);</span></code></dt>
<dd>Sets len consecutive bytes to the value c, starting at location b.</dd>
</dl>
</div>
<p>To return to the general discussion of scope, the third type of variable scope centers around the
<code class="docutils literal notranslate"><span class="pre">static</span></code> keyword. Variables that are declared as <code class="docutils literal notranslate"><span class="pre">static</span></code> occupy a sort of middle ground between
global and local. Static scope indicates that the variable is <strong>lexically bound but persistent</strong>.
The phrase <em>lexically bound</em> means that the variable name can only be referenced by the code block
that contains the declaration; code blocks in C are defined by files, loop constructs (e.g., <code class="docutils literal notranslate"><span class="pre">for</span></code>
or <code class="docutils literal notranslate"><span class="pre">while</span></code> loops) curly braces (<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>). In <a class="reference external" href="#cla-22">Code Listing A.22</a>, line 14 declares
<code class="docutils literal notranslate"><span class="pre">local_static</span></code> so that it can only be accessed from within the helper() function; no other
function can have direct access to this variable. Line 23 declares hidden so that it is only
accessible within the block of code in lines 22 – 25; once that block is finished, as the comment on
line 26 indicates, the hidden variable can no longer be accessed, even within the <code class="docutils literal notranslate"><span class="pre">helper()</span></code>
function. The <code class="docutils literal notranslate"><span class="pre">global_static</span></code> variable, declared on line 8, is visible throughout all of the
functions in this particular file. However, if this file is compiled and linked along with a
different piece of C code, that other code would not be able to access <code class="docutils literal notranslate"><span class="pre">global_static</span></code>.</p>
<p>In addition to being lexically bound, static variables are persistent. Unlike normal local variables
that are created and destroyed with every call of a function, there is only one copy of each static
variable, and that copy persists for the duration of the process execution. In that way, static
variables are akin to global variables. <a class="reference external" href="#cla-23">Code Listing A.23</a> demonstrates this fact by
calling <code class="docutils literal notranslate"><span class="pre">helper()</span></code> twice. Each time that <code class="docutils literal notranslate"><span class="pre">helper()</span></code> is called, the <code class="docutils literal notranslate"><span class="pre">local</span></code> variable is
initialized to 5 and incremented twice. In contrast, <code class="docutils literal notranslate"><span class="pre">local_static</span></code> is initialized once to the
value 10. With the first call of <code class="docutils literal notranslate"><span class="pre">helper()</span></code>, line 20 of <a class="reference external" href="#cla-22">Code Listing A.22</a> prints this
initial value and increments it to 11. This value is then used when <code class="docutils literal notranslate"><span class="pre">helper()</span></code> is called again. In
other words, the initialization on line 14 of <a class="reference external" href="#cla-22">Code Listing A.22</a> is very deceiving; it
only executes once, rather than every time the function is called. Similarly, the static variable
hidden is also initialized once to 20 and incremented during the first call to <code class="docutils literal notranslate"><span class="pre">helper()</span></code>; the
second call to the function begins with the modified value 21.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-23"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.23:</span>
<span class="cm">   Using a separate file to call the function in Code Listing A.22</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cm">/* Function prototypes and extern variable declarations</span>
<span class="cm">   are normally declared in a separate .h header file */</span>
<span class="kt">void</span> <span class="nf">helper</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">global</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;global is originally %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">global</span><span class="p">);</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;First call to helper:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">helper</span><span class="p">();</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Second call to helper:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">helper</span><span class="p">();</span>

  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;global ends up as %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">global</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Lines 9 and 10 of <a class="reference external" href="#cla-23">Code Listing A.23</a> illustrate behavior that is normally specified in a
header file. For instance, if <a class="reference external" href="#cla-22">Code Listing A.22</a> was stored in a file called
<code class="docutils literal notranslate"><span class="pre">&quot;scope.c&quot;</span></code>, these two lines would likely be in a file called <code class="docutils literal notranslate"><span class="pre">&quot;scope.h&quot;</span></code> that would look like
<a class="reference external" href="#cla-24">Code Listing A.24</a>. The first line is a <em>function prototype</em> for helper(), which
serves the purpose of declaring the parameter types and return type for the function. The compiler
uses this information to know that any calls to the function are correctly formatted. The <code class="docutils literal notranslate"><span class="pre">extern</span></code>
keyword is used for a global variable to indicate that this variable is defined <em>somewhere</em>. When
<a class="reference external" href="#cla-23">Code Listing A.23</a> is compiled (before it is linked), the compiler only needs to know
that <code class="docutils literal notranslate"><span class="pre">global</span></code> is an <code class="docutils literal notranslate"><span class="pre">int</span></code> variable to know that lines 15 and 22 are valid. The linking process
will later tie these lines of code to the correct variable.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-24"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.24:</span>
<span class="cm">   A header file for the public interface of Code Listing A.22</span>
<span class="cm"> */</span>

<span class="cp">#ifdef __csf_appendix_scope_h__</span>
<span class="cp">#define __csf_appendix_scope_h__</span>

<span class="kt">void</span> <span class="nf">helper</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">global</span><span class="p">;</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<div class="topic border border-dark rounded-lg alert-danger px-2 mb-3">
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/CSF-Images-BugWarning.png"><img alt="Decorative bug warning" src="_images/CSF-Images-BugWarning.png" style="width: 90%;" /></a>
</div>
<p class="topic-title first pt-2 mb-1">Bug Warning</p><hr class="mt-1" />
<p>Global variables should never appear in a header file without the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword. Without this
keyword, the C compiler will think that the programmer’s intention is to create an instance of this
global variable in the compiled object. As such, if the header file is included in multiple C
source code files, the compiler will create such a global variable inside each of them. During the
compilation stage, this is not a problem; the problem arises later during the linking stage.
Specifically, C strictly indicates that there can be only one instance of a variable name in a
given scope. (Note that the type doesn’t matter; <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">x</span></code> would not be allowed in
the same scope.) When the linker would try to combine the compiled objects into a single
executable, it would report an error due to multiple global variables with the same name.</p>
</div>
<div class="section" id="function-parameters-and-return-values">
<h2>10.5.1. Function Parameters and Return Values<a class="headerlink" href="#function-parameters-and-return-values" title="Permalink to this headline">¶</a></h2>
<p>C functions can be defined to take any number of parameters and return a single value. This
definition follows from the mathematical definition of a function. For example, consider the
following mathematical function definition:</p>
<center>
<span class="math inline" style="font-size: 1.5em">$f(x) = x^2$</span>
</center><p>The function f(x) takes one input parameter (x) and maps it to a single value by squaring it. C
functions operate on the same principle, as shown in <a class="reference external" href="#cla-25">Code Listing A.25</a>. In this
example, the <code class="docutils literal notranslate"><span class="pre">add()</span></code> function takes two input parameters, adds them together, and returns the
result; that is, <code class="docutils literal notranslate"><span class="pre">add()</span></code> would map two input values to a particular output in the traditional
mathematical sense. Observe that function parameters operate like local variables; the variables
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> can be accessed from within the function body and their values are not persistent
from one call to the next.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-25"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0">1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.25:</span>
<span class="cm">   A trivial C function to add two numbers</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">add</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This traditional notion of a function does not completely match with the common use of C functions
as <em>subroutines</em>. The semantic difference is that a subroutine is simply a
modular piece of code to encapsulate some behavior; subroutines are not bound by the idea of mapping
inputs to a single return value. One common example of this is using a <code class="docutils literal notranslate"><span class="pre">void</span></code> return type, which
indicates that there is no mapped result. In mathematical terms, it would be nonsensical to talk
about a function f(x) that does not map any input value x to a specific output; such an f(x) would
not be a function <a class="footnote-reference" href="#f57" id="id10">[1]</a> in the conventional sense. In C subroutines, it happens all the time.
Consider a function that takes two inputs and passes them to <code class="docutils literal notranslate"><span class="pre">printf()</span></code> along with a format
string; this function would have no need for a return type.</p>
<p>When working with subroutines rather than mathematical functions, there are several types of
behavior that C supports to create flexible programming styles. One such behavior is the ability to
specify a variable number of parameters. Perhaps the most common example of this behavior is the
<code class="docutils literal notranslate"><span class="pre">printf()</span></code> function. The first parameter is a string constant to represent how the output is to be
formatted; the number of additional parameters depends on the number of format specifiers (such as
<code class="docutils literal notranslate"><span class="pre">%d</span></code> or <code class="docutils literal notranslate"><span class="pre">%s</span></code>). The function prototype for <code class="docutils literal notranslate"><span class="pre">printf()</span></code> is written as follows:</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-2 mb-3 notranslate"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="kt">int</span> <span class="nf">printf</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>The ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>) here is not this book’s notation to indicate “more stuff here.” Rather, the ellipsis is part of the C syntax to indicate that there are additional variables of unknown types. In the case of <code class="docutils literal notranslate"><span class="pre">printf()</span></code>, only the first argument’s type (<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code>) is explicitly declared. <a class="reference external" href="#cla-26">Code Listing A.26</a> demonstrates how to define a function with a variable-length parameter list. The first key feature is that the <code class="docutils literal notranslate"><span class="pre">stdarg.h</span></code> header file must be included (line 6). This header file defines a number of preprocessor macros—which look like functions—to process the arguments.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-26"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.26:</span>
<span class="cm">   Defining a function with a variable-length parameter list</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">sum</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="cm">/* Declare and initialize the variable argument list</span>
<span class="cm">     with the specified length */</span>
  <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
  <span class="n">va_start</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

  <span class="cm">/* Loop through each argument, adding it to the total */</span>
  <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Get the next argument as an int */</span>
      <span class="kt">int</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">va_arg</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
      <span class="n">total</span> <span class="o">+=</span> <span class="n">arg</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">va_end</span> <span class="p">(</span><span class="n">args</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In <a class="reference external" href="#cla-26">Code Listing A.26</a>, the sum() function takes a <code class="docutils literal notranslate"><span class="pre">size_t</span></code> variable to indicate the number of integer values to add together. To begin processing these inputs, lines 13 and 14 declare and instantiate a variable-length argument list (type <code class="docutils literal notranslate"><span class="pre">va_list</span></code>) of the specified length. From there, each argument can be accessed from the list exactly once, using the <code class="docutils literal notranslate"><span class="pre">va_arg()</span></code> macro (line 21). The second argument to this function indicates the type of the variable; in this case, each argument in the list will be converted to an <code class="docutils literal notranslate"><span class="pre">int</span></code>. <a class="reference external" href="#cla-27">Code Listing A.27</a> demonstrates how to use the <code class="docutils literal notranslate"><span class="pre">sum()</span></code> function. In both calls, the first argument is required to indicate the number of arguments that should be added together; line 5 only passes the value 42, whereas line 7 will calculate the sum 2 + 4 + 6 + 8.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-27"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.27:</span>
<span class="cm">   Calling a function with a variable-length parameter list</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">sum</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Total is %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span> <span class="c1">// prints 42</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">sum</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Total is %d</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span> <span class="c1">// prints 20</span>
</pre></div>
</td></tr></table></div>
<div class="topic border border-dark rounded-lg alert-danger px-2 mb-3">
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/CSF-Images-BugWarning.png"><img alt="Decorative bug warning" src="_images/CSF-Images-BugWarning.png" style="width: 90%;" /></a>
</div>
<p class="topic-title first pt-2 mb-1">Bug Warning</p><hr class="mt-1" />
<p>It is common to return pointers for a variety of reasons. For instance, a function might dynamically
allocate some space (see the section on Pointers and Dynamic Allocation) to use as a buffer or make
a copy of a string. However, it is critical that a <strong>function should never return a pointer to a
local variable</strong>. This rule includes returning local copies of strings, as shown in the following
example:</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="kt">char</span> <span class="o">*</span>
<span class="nf">broken_function</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">string</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Hello!&quot;</span><span class="p">;</span> <span class="c1">// string exists in stack frame</span>
  <span class="k">return</span> <span class="n">string</span><span class="p">;</span>            <span class="c1">// stack frame becomes invalid</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The problem with returning pointers to local variables is that the data associated with the variable
exists in a stack frame that is linked to the function call; once the function returns, the stack
frame is de-allocated, making any future access to this part of memory invalid. Unfortunately, such
code occasionally works without crashing because the stack frame has not been overwritten yet; this
makes debugging the code very difficult, because the crashes seem random.</p>
</div>
</div>
<div class="section" id="call-by-reference-parameters">
<h2>10.5.2. Call-by-Reference Parameters<a class="headerlink" href="#call-by-reference-parameters" title="Permalink to this headline">¶</a></h2>
<p>The limitation of returning only a single value can be frustrating, as a complex subroutine may need
to provide the caller with multiple pieces of data. One example of this need is a function that is
supposed to return a pointer. A common convention for such functions is to return the <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
pointer if an error occurs in the function. However, this approach does not explain what the error
was or how the caller should react; if the function took a file descriptor in as input, was the
problem that the file was closed, the user running the program did not have access to the file, or
the file had no contents? Clearly, it would be desirable to provide such information.</p>
<p>One approach to providing multiple returns is simply to cheat: use global variables. This is the
approach that is commonly used for error indications as in the previous example. If the function
returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> because of an error, it can also set the <code class="docutils literal notranslate"><span class="pre">errno</span></code> global variable to indicate the
reason why the failure occurred. With few clearly defined exceptions (such as <code class="docutils literal notranslate"><span class="pre">errno</span></code>), <strong>this
approach is undesirable and generally unsafe</strong>. Global variables require the programmer to be
careful to avoid name collisions. Furthermore, the very nature of global variables allows any
function to change them at any point (assuming the variable name is made visible with <code class="docutils literal notranslate"><span class="pre">extern</span></code>).
This global accessibility is particularly fraught in concurrent systems, as multiple threads might
simultaneously need to call the same function, potentially creating a race condition with
interleaved modifications of the variable.</p>
<p>A better approach is to use <em>call-by-reference</em> parameters. Consider performing traditional
integer division as taught in the early grades of school. Calculating 17 ÷ 5 has two parts to the
answer: a quotient of 3 and a remainder of 2 (since 5 * 3 + 2 = 17). <a class="reference external" href="#cla-28">Code Listing A.28</a>
demonstrates how to define a division function using a call-by-reference parameter.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-28"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.28:</span>
<span class="cm">   Returning multiple parameters with call-by-reference</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">divide</span> <span class="p">(</span><span class="kt">int</span> <span class="n">dividend</span><span class="p">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">remainder</span><span class="p">)</span>
<span class="p">{</span>
  <span class="cm">/* Set the remainder (dividend % divisor), then</span>
<span class="cm">     return the quotient (dividend / divisor) */</span>
  <span class="n">assert</span> <span class="p">(</span><span class="n">remainder</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="o">*</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">dividend</span> <span class="o">%</span> <span class="n">divisor</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">dividend</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="figure mb-2 align-right" id="id15" style="width: 30%">
<span id="stackframes"></span><a class="reference internal image-reference" href="_images/CSF-Images.A.5.png"><img class="p-3 mb-2 align-center border border-dark rounded-lg" alt="Stack frames for main() and divide()" src="_images/CSF-Images.A.5.png" style="width: 90%;" /></a>
<p class="caption align-center px-3"><span class="caption-text"> Figure 10.5.6: Stack frames for <code class="docutils literal notranslate"><span class="pre">main()</span></code> and <code class="docutils literal notranslate"><span class="pre">divide()</span></code></span></p>
</div>
<p>In this function, the <code class="docutils literal notranslate"><span class="pre">remainder</span></code> parameter is a pointer to an <code class="docutils literal notranslate"><span class="pre">int</span></code>. The <code class="docutils literal notranslate"><span class="pre">assert()</span></code> call on
line 10 is a safety check that will prevent anyone from passing a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer to this function.
Within the <code class="docutils literal notranslate"><span class="pre">divide()</span></code> function, we will use this pointer to change the original <code class="docutils literal notranslate"><span class="pre">int</span></code>’s value.
Line 11 performs this by dereferencing the pointer and storing the result of the modulus operation
<code class="docutils literal notranslate"><span class="pre">dividend</span> <span class="pre">%</span> <span class="pre">divisor</span></code>. Once we have done this, line 12 returns the normal C integer division
quotient (<code class="docutils literal notranslate"><span class="pre">dividend</span> <span class="pre">/</span> <span class="pre">divisor</span></code>). <a class="reference external" href="#cla-29">Code Listing A.29</a> demonstrates how to call this
function by passing the address of <code class="docutils literal notranslate"><span class="pre">remainder</span></code>. (Recall that pointers store addresses, so the
address of a variable becomes a pointer.) <a href="Functions.html#stackframes">Figure  10.5.6</a> illustrates the
relationship between the stack frames for <code class="docutils literal notranslate"><span class="pre">main()</span></code> (<a class="reference external" href="#cla-29">Code Listing A.29</a>) and the call to
<code class="docutils literal notranslate"><span class="pre">divide()</span></code>. The remainder parameter for <code class="docutils literal notranslate"><span class="pre">divide()</span></code> contains a pointer back to the <code class="docutils literal notranslate"><span class="pre">rem</span></code> variable
in <code class="docutils literal notranslate"><span class="pre">main()</span></code>’s stack frame.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-29"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.29:</span>
<span class="cm">   Calling a function with a variable-length parameter list</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">rem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* pass the address of rem for divide to set its value */</span>
<span class="kt">int</span> <span class="n">quot</span> <span class="o">=</span> <span class="n">divide</span> <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>

<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;17 ÷ 5 is %d R %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="topic border border-dark rounded-lg alert-danger px-2 mb-3">
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/CSF-Images-BugWarning.png"><img alt="Decorative bug warning" src="_images/CSF-Images-BugWarning.png" style="width: 90%;" /></a>
</div>
<p class="topic-title first pt-2 mb-1">Bug Warning</p><hr class="mt-1" />
<p>A very common mistake among programmers who are new to C’s call-by-reference parameters is to try to
match the variable declaration instead of using the address-of operator (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) as illustrated here:</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-2 mb-3 notranslate"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="kt">int</span> <span class="o">*</span><span class="n">remainder</span><span class="p">;</span> <span class="c1">// Don&#39;t EVER leave a pointer uninitialized!</span>
<span class="kt">int</span> <span class="n">quotient</span> <span class="o">=</span> <span class="n">divide</span> <span class="p">(</span><span class="mi">17</span><span class="p">,</span> <span class="mi">5</span> <span class="n">remainder</span><span class="p">);</span>
</pre></div>
</div>
<p>This code would probably work successfully, but <strong>it is wrong and very dangerous</strong>. Yes, the types
are correct. The <code class="docutils literal notranslate"><span class="pre">remainder</span></code> variable is an <code class="docutils literal notranslate"><span class="pre">int*</span></code>, which matches the type that the
<code class="docutils literal notranslate"><span class="pre">divide()</span></code> function expects. The problem lies in the answer to this question: What is the initial
value of <code class="docutils literal notranslate"><span class="pre">remainder</span></code>? In other words, what portion of memory is <code class="docutils literal notranslate"><span class="pre">remainder</span></code> <em>pointing to</em>?</p>
<p>In C, local variables are never initialized unless the programmer explicitly does so. The example
code above declares a pointer, but does not initialize it. When this happens, the value of the
variable (<code class="docutils literal notranslate"><span class="pre">remainder</span></code> in this case) is whatever random values happen to already be there on the
stack. In other words, <strong>this code tells the machine to initialize</strong> <code class="docutils literal notranslate"><span class="pre">remainder</span></code> <strong>so that it
points to a random location</strong>. In the context of a large, complex program, this code will produce a
segmentation fault <em>if we are lucky</em>! The segmentation fault would be an indication that there is a
problem. If we are unlucky, <code class="docutils literal notranslate"><span class="pre">remainder</span></code> (by random chance) points to a valid location; the
problem is that the <code class="docutils literal notranslate"><span class="pre">divide()</span></code> function will overwrite the contents of that random location.
Depending on that that memory location is supposed to be storing, this bug could cause a completely
unrelated part of the program to crash seconds, minutes, or hours later, with no indication that
this call to <code class="docutils literal notranslate"><span class="pre">divide()</span></code> is the cause.</p>
<p>The difference between this code and <a class="reference external" href="#cla-29">Code Listing A.29</a> is that the address-of operator
requires us to know what we are initializing the pointer to. That is, it requires us to answer
“address of <em>what</em>?” By passing <code class="docutils literal notranslate"><span class="pre">&amp;remainder</span></code> for an <code class="docutils literal notranslate"><span class="pre">int</span></code> variable, rather than declaring and
passing an <code class="docutils literal notranslate"><span class="pre">int*</span></code>, we are providing the answer: the address of the local variable <code class="docutils literal notranslate"><span class="pre">remainder</span></code>
that was just declared.</p>
</div>
</div>
<div class="section" id="arrays-as-parameters">
<h2>10.5.3. Arrays as Parameters<a class="headerlink" href="#arrays-as-parameters" title="Permalink to this headline">¶</a></h2>
<p>In the earlier discussion on arrays, we made the observation that array lengths must be passed as
explicit parameters when an array is passed to another function. The reason for this is that arrays
are always passed as call-by-reference parameters. <a class="reference external" href="#cla-30">Code Listing A.30</a> provides an
example of a function that takes an array as a parameter and modifies the values stored in the
array. On line 6, the parameter list indicates that values is an array of int values. This
declaration is not entirely true; values is, in fact, just a pointer to an <code class="docutils literal notranslate"><span class="pre">int</span></code>. Using the
declaration <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">values[]</span></code> instead of <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*values</span></code> serves the purpose of indicating how values
will be used, but both declarations are acceptable.</p>
<div class="highlight-c border border-dark rounded-lg bg-light px-0 mb-3 notranslate" id="cla-30"><table class="highlighttable"><tr><td class="linenos px-0 mx-0"><div class="linenodiv"><pre class="mb-0"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight bg-light"><pre class="mb-0"><span></span><span class="cm">/* Code Listing A.30:</span>
<span class="cm">   All arrays are passed as call-by-reference pointers</span>
<span class="cm"> */</span>

<span class="kt">void</span>
<span class="nf">dub_all</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">values</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
  <span class="n">dub_all</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;data[%zd] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

  <span class="kt">int</span> <span class="n">faker</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">dub_all</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">faker</span><span class="p">);</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;faker is now %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">faker</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="figure mb-2 align-right" id="id16" style="width: 30%">
<span id="stackframesdub"></span><a class="reference internal image-reference" href="_images/CSF-Images.A.6.png"><img class="p-3 mb-2 align-center border border-dark rounded-lg" alt="Stack frames for main() and dub_all()" src="_images/CSF-Images.A.6.png" style="width: 90%;" /></a>
<p class="caption align-center px-3"><span class="caption-text"> Figure 10.5.8: Stack frames for <code class="docutils literal notranslate"><span class="pre">main()</span></code> and <code class="docutils literal notranslate"><span class="pre">dub_all()</span></code></span></p>
</div>
<p><a href="Functions.html#stackframesdub">Figure  10.5.8</a> illustrates the relationship between <code class="docutils literal notranslate"><span class="pre">main()</span></code> and the first
call to <code class="docutils literal notranslate"><span class="pre">dub_all()</span></code> (for simplicity, the variable <code class="docutils literal notranslate"><span class="pre">faker</span></code> is not shown). Although <code class="docutils literal notranslate"><span class="pre">data</span></code> is
ostensibly passed to the <code class="docutils literal notranslate"><span class="pre">dub_all()</span></code> function, it is actually just the address of the first
element that is passed. This structure is consistent with an observation that we made earlier: array
names are simply aliases for the address of their first element.</p>
<p>To emphasize the point even further, observe that line 21 makes another call to <code class="docutils literal notranslate"><span class="pre">dub_all()</span></code>. In
this call, we are passing the address of the local variable <code class="docutils literal notranslate"><span class="pre">faker</span></code> as an <em>array</em> of size 1. Since
array names and pointers can both be indexed using the array bracket notation, <code class="docutils literal notranslate"><span class="pre">dub_all()</span></code> can
still successfully access the faker variable and change its value. From the perspective of
<code class="docutils literal notranslate"><span class="pre">dub_all()</span></code>, there is no way to tell if the <code class="docutils literal notranslate"><span class="pre">values</span></code> parameter is pointing to a single <code class="docutils literal notranslate"><span class="pre">int</span></code>
or something that was actually declared as an array. For this reason, the length of the array must
also be passed as a parameter to <code class="docutils literal notranslate"><span class="pre">dub_all()</span></code> to control the number of iterations in that
function’s <code class="docutils literal notranslate"><span class="pre">for</span></code>-loop on line 8.</p>
<table class="docutils footnote" frame="void" id="f57" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[1]</a></td><td>Pedantically, such an f(x) would fit the definition of a mathematical function with an
empty codomain. Such a function would not be conventional, however.</td></tr>
</tbody>
</table>
</div>
</div>


    </div>

  </body>
  </html>